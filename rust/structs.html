<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Structs - Olu&#x27;s Rust Cafe</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Olu&#x27;s Rust Cafe</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<ul>
<li>A struct or structure lets you create a group of related fields</li>
<li>A struct is like the set of fields in a class (i.e., in Object-Oriented Programming)</li>
<li>A struct is similar to tuples, but with structs the fields are given names and structs can have functions associated with them</li>
</ul>
<h2 id="declaring-a-struct"><a class="header" href="#declaring-a-struct">Declaring a struct</a></h2>
<ul>
<li>You declare a struct with the <code>struct</code> keyword. For example, consider the Employee struct below:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct Employee {
    id: i32, 
    first_name: String,
    middle_name: String,
    last_name: String,
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="instantiating-a-struct"><a class="header" href="#instantiating-a-struct">Instantiating a struct</a></h2>
<p>You instantiate a struct as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>fn main() {
    let emp = Employee {
        id : 11,
        first_name : String::from("Olu"),
        middle_name : String::from("Timi"),
        last_name : String::from("Toyin")
    };
} </code></pre></pre>
<h2 id="accessing-a-structs-fields"><a class="header" href="#accessing-a-structs-fields">Accessing a struct's fields</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>fn main() {
    let emp = Employee {
        id : 11,
        first_name : String::from("Olu"),
        middle_name : String::from("Timi"),
        last_name : String::from("Toyin")
    };
    
    println!("{}:{} {} {}", emp.id, emp.first_name, emp.middle_name, emp.last_name);
} </code></pre></pre>
<h2 id="changing-the-value-assigned-to-a-structs-field"><a class="header" href="#changing-the-value-assigned-to-a-structs-field">Changing the value assigned to a struct's field</a></h2>
<ul>
<li>To update the value assigned to a struct's field, you must make it mutable using the <code>mut</code> keyword:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>
fn main() {
    let mut emp = Employee {
        id : 11,
        first_name : String::from("Olu"),
        middle_name : String::from("Timi"),
        last_name : String::from("Toyin")
    };
    
    println!("{}:{} {} {}", emp.id, emp.first_name, emp.middle_name, emp.last_name);
    emp.middle_name = String::from("Tayo");
    println!("{}:{} {} {}", emp.id, emp.first_name, emp.middle_name, emp.last_name);    
} </code></pre></pre>
<h2 id="printing-a-struct"><a class="header" href="#printing-a-struct">Printing a struct</a></h2>
<p>If you ordinarily pass an instance of your struct to <code>println!</code>, Rust will complain that your struct
doesn't implement<code>std::fmt::Display</code> and it suggests to you to use <code>{:?}</code> (or <code>{:#?}</code> for pretty-print) instead
in the placeholder for <code>println</code>. Run the below snippet to see.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>
fn main() {
    let emp = Employee {
        id : 11,
        first_name : String::from("Olu"),
        middle_name : String::from("Timi"),
        last_name : String::from("Toyin")
    };
    
    println!("{}", emp);
}</code></pre></pre>
<p>Let's update the <code>println!("{}", emp);</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>
fn main() {
    let emp = Employee {
        id : 11,
        first_name : String::from("Olu"),
        middle_name : String::from("Timi"),
        last_name : String::from("Toyin")
    };
    
    println!("{:?}", emp);
    println!("{:#?}", emp);
}</code></pre></pre>
<p>Now it complains that your struct doesn't implement <code>Debug</code>.
We can fix this by adding the attribute: <code>#[derive(Debug)]</code> to the top of your struct definition like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>
fn main() {
    let emp = Employee {
        id : 11,
        first_name : String::from("Olu"),
        middle_name : String::from("Timi"),
        last_name : String::from("Toyin")
    };
    
    println!("{:?}", emp);
    println!("{:#?}", emp);
}</code></pre></pre>
<h2 id="returning-a-struct-from-a-function"><a class="header" href="#returning-a-struct-from-a-function">Returning a struct from a function</a></h2>
<p>You can return a struct from a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>
fn main() {
  let emp = an_employee(String::from("Olu"), String::from("Time"), String::from("Jacobs"));
  println!("{:?}", emp);
}

fn an_employee(first_name: String, middle_name: String, last_name: String) -&gt; Employee {
    Employee {
        id : 12,
        first_name : first_name,
        middle_name : middle_name,
        last_name : last_name
    }
}</code></pre></pre>
<h3 id="use-the-field-init-shorthand-syntax"><a class="header" href="#use-the-field-init-shorthand-syntax">Use the Field init shorthand syntax</a></h3>
<p>In the previous snippet, the parameters of function <code>an_employee</code> has the same name as the struct's fields. In such a case, we
can shorten the <code>field_name: parameter_name</code> to simply <code>parameter_name</code> like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>
fn main() {
  let emp = an_employee(String::from("Olu"), String::from("Time"), String::from("Jacobs"));
  println!("{:?}", emp);
}

fn an_employee(first_name: String, middle_name: String, last_name: String) -&gt; Employee {
    Employee {
        id : 12,
        first_name,
        middle_name,
        last_name
    }
}</code></pre></pre>
<h2 id="updating-a-struct-using-the-struct-update-syntax"><a class="header" href="#updating-a-struct-using-the-struct-update-syntax">Updating a struct using the struct update syntax</a></h2>
<p>The struct update syntax allows you to create a new struct from an existing struct's fields and only change the values you want to change.
In the snippet below, we create <code>emp1</code> and use it to create <code>emp2</code> only changing the value of middle_name from <code>emp1</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Employee {
</span><span class="boring">   id: i32, 
</span><span class="boring">   first_name: String,
</span><span class="boring">   middle_name: String,
</span><span class="boring">   last_name: String,
</span><span class="boring">}
</span>
fn main() {
  let emp1 = an_employee(String::from("Olu"), String::from("Timi"), String::from("Jacobs"));
  println!("{:?}", emp1);
  
  let emp2 = Employee {
        middle_name : String::from("John"),
        ..emp1
  };
  println!("{:?}", emp2);
}

fn an_employee(first_name: String, middle_name: String, last_name: String) -&gt; Employee {
    Employee {
        id : 12,
        first_name : first_name,
        middle_name : middle_name,
        last_name : last_name
    }
}</code></pre></pre>
<h2 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple structs</a></h2>
<p>They are structs which don't have names associated with their fields; rather they just have the types.
Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other tuples (see <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">tuple structs</a> )
For example,</p>
<pre><pre class="playground"><code class="language-rust">  #[derive(Debug)]
  struct Point(i32, i32);
  
  fn main() {
    let point1 = Point(3, 10);
    
    println!("{:?}", point1);
  }</code></pre></pre>
<h3 id="destructure-tuple-structs"><a class="header" href="#destructure-tuple-structs">Destructure tuple structs</a></h3>
<p>You can also destructure tuple structs in a similar fashion to the way you do with tuples but in the case of tuple structs you must
also specify the name of the struct. See example below showing tuple structs and an ordinary tuple.</p>
<pre><pre class="playground"><code class="language-rust">  #[derive(Debug)]
  struct Point(i32, i32);
  
  fn main() {
    let point1 = Point(3, 10); //tuple struct
    let point2 = (4, 15); // ordinary tuple
 
    println!("Point 1: {:?}", point1);
    println!("Point 2: {:?}", point2);
    
    let Point(a, b) = point1; //destructuring mentions the name of the struct
    let (x, y) = point2; // destructuring just uses the normal tuple syntax i.e., (x, y)
    
    println!("{}, {}",a, b);
    println!("{}, {}",x, y);
  }</code></pre></pre>
<h2 id="unit-structs"><a class="header" href="#unit-structs">Unit structs</a></h2>
<p>A unit struct is a struct which has no data in it. It is simply defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
<span class="boring">}</span></code></pre></pre>
<p>Unit structs can be useful when you want to implement a trait on some type but don’t have any data that you want to store in the type itself.
(source:<a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields">unit structs</a> )</p>
<h2 id="ownership-of-struct-data"><a class="header" href="#ownership-of-struct-data">Ownership of Struct data</a></h2>
<p>All the examples we have seen so far have used types owned by the struct such as <code>String</code> instead of <code>&amp;str</code> and types which implement the <code>Copy</code> trait.
t’s also possible for structs to store references to data owned by something else, but to do so requires the use of lifetimes (source: <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#ownership-of-struct-data">ownership of struct data</a>).
Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. We'll discuss this more later.</p>
<h2 id="associated-functions-in-structs"><a class="header" href="#associated-functions-in-structs">Associated functions in structs</a></h2>
<p>It is possible to create functions within the context of a struct. Thus, such functions are called associate functions because they are defined within the struct.
To define an associated function you do so in that's called an <code>impl</code> definition for the struct. For example, consider the following <code>Time</code> struct
and an associated function called <code>new</code> for instantiating an instance of the struct</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Time {
   hour: u8,
   minute: u8,
   second: u8
}

impl Time {
   fn new(hour: u8, minute: u8, second: u8) -&gt; Self {
      Self {
         hour, //showcasing field init syntax
         minute: minute,
         second: second
      }
   }
}

fn main() {
   let play_time = Time::new(12, 30, 0);
   println!("{:?} is play time.", play_time);
}
</code></pre></pre>
<p>In the above, note that in the function body we are instantiating a <code>Self</code> and that the return type of the <code>new</code> function is also a Self.
Self is a special keyword which is just an alias for the struct in which this associated function resides in, i.e., <code>Time</code> struct in this case.
Thus, we could have just specified <code>Time</code> everywhere we have used <code>Self</code>.</p>
<h3 id="methods-in-structs"><a class="header" href="#methods-in-structs">Methods in structs</a></h3>
<pre><pre class="playground"><code class="language-rust">mod data {

    pub struct AgeHeight { 
        age: i32, 
        height: f64
    }


    impl AgeHeight {
        pub fn new(age:i32, height: f64) -&gt; Self {
            AgeHeight { age: age, height:height }
        }

        pub fn get_age(&amp;self) -&gt; i32 {
            self.age
        }

        pub fn get_height(&amp;self) -&gt; f64 {
            self.height
        }
    }

}

fn main() {

    let age_height1 = data::AgeHeight::new(42, 1.85);
    let age_height2 = data::AgeHeight::new(41, 1.70);

    println!("Age {} height {}", age_height1.get_age(), age_height1.get_height());
    println!("Age {} height {}", age_height2.get_age(), age_height2.get_height());
 }</code></pre></pre>
<h2 id="passing-a-struct-to-a-function"><a class="header" href="#passing-a-struct-to-a-function">Passing a struct to a function</a></h2>
<h3 id="when-the-struct-contains-only-types-that-implement-copy-trait"><a class="header" href="#when-the-struct-contains-only-types-that-implement-copy-trait">When the struct contains only types that implement Copy trait</a></h3>
<h3 id="when-the-struct-contains-only-types-that-implement-drop-trait"><a class="header" href="#when-the-struct-contains-only-types-that-implement-drop-trait">When the struct contains only types that implement Drop trait</a></h3>
<h3 id="when-the-struct-contains-types-that-implement-copy-as-well-as-those-that-implement-drop"><a class="header" href="#when-the-struct-contains-types-that-implement-copy-as-well-as-those-that-implement-drop">When the struct contains types that implement Copy as well as those that implement Drop</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="moving_borrowing_slicing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="moving_borrowing_slicing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
