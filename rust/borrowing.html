<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Borrowing - Olu&#x27;s Rust Cafe</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Olu&#x27;s Rust Cafe</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="borrowingreferences"><a class="header" href="#borrowingreferences">Borrowing/References</a></h1>
<p>Borrowing in Rust means obtaining a reference to some variable.
From now on, we'll use phrases "obtaining a reference" and "borrowing" interchangeably.
When you obtain a reference to a variable <code>foo</code> and assign it to another variable <code>bar</code>,
the variable <code>bar</code> is the borrower and the variable <code>foo</code> is the owner/lender. Thus, <code>bar</code> refers
to <code>foo</code> or we can say <code>bar</code> borrows <code>foo</code>'s value.
Variable <code>bar</code> can freely read the data owned by <code>foo</code> but it cannot modify the data unless otherwise specified via the <code>mut</code> keyword.
(more on this below)</p>
<p>Usually in Rust, when you want to assign a heap allocated variable to another variable
or pass it to a function, what you want is to <em>borrow</em> the data that variable refers to (or succinctly borrow the variable) rather than taking ownership of it as we
saw in the previous section. In order to <em>borrow</em> a variable, you obtain a reference to that variable.</p>
<p>Let's use the <code>String</code> type as an example:</p>
<pre><pre class="playground"><code class="language-rust editable">
fn main() {
  let fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp;fruit; //borrow occurs here i.e. fruit2 is a reference to fruit

  println!("Fruit2 is {}", fruit2);
  
  //Can still use fruit variable here
  println!("Fruit is {}", fruit);
} </code></pre></pre>
<p>The diagram below illustrates what happens when you <em>borrow</em> a variable:</p>
<p><img src="images/borrowing.jpg" alt="borrowing" /></p>
<p>Similarly, for method calls, you can pass a reference as argument (i.e. borrowed the variable)
to the function call like so:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let name = String::from("Olu");

  println!("Name is {}", name);

  say_hello(&amp;name); //borrow occurs here
  
  //Can still use name variable here
  println!("Name is {}", name);
} 

fn say_hello(name: &amp;String) { //name is a reference to a String passed into the function
   println!("Hello {}", name)
}</code></pre></pre>
<h2 id="a-reference-ie-a-borrowed-variable-is-immutable-by-default"><a class="header" href="#a-reference-ie-a-borrowed-variable-is-immutable-by-default">A reference (i.e. a borrowed variable) is immutable by default</a></h2>
<p>By default, when you borrow a variable, the reference is immutable. That is, by default, you cannot<br />
use the reference to change the variable. Example, the below snippet fails:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp;fruit; //borrow occurs here i.e. fruit2 is an immutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  let another_fruit = String::from("pear");
  
  fruit2 = &amp;another_fruit; //compiler error here
  
  println!("Fruit2 is now {}", fruit2);
} </code></pre></pre>
<p>You'll see from the error message shown that <code>fruit2</code> is immutable by default, just like any other
rust variable (i.e. when you do a <code>let foo = ...</code>, the variable, reference or not, is always immutable by default).
Adding the <code>mut</code> keyword to <code>fruit2</code> declaration sorts it:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let mut fruit2 = &amp;fruit; //borrow occurs here i.e. fruit2 is a mutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  let another_fruit = String::from("pear");
  
  fruit2 = &amp;another_fruit; //Now you can assign a new reference to fruit2
  
  println!("Fruit is still {}", fruit); // still refers to the the "apple" String
  println!("Fruit2 is now {}", fruit2); //now refers to the "pear" String
} </code></pre></pre>
<p>In the above, example, we initially assigned a reference to a <code>String</code> containing "apple"
to <code>fruit2</code> and then we assigned another reference to a different <code>String</code> containing "pear"
to <code>fruit</code>. Thus we made <code>fruit2</code> refer to two different Strings (one at a time) over the course of the program.
What if we wanted to use <code>fruit2</code> to modify the original String i.e. the <code>String::from("apple")</code>?</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let mut fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp; mut fruit; //borrow occurs here i.e. fruit2 is a mutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  fruit2.push_str(" and pears");
  
  //Both fruit and fruit2 refer to the same `String`
  println!("Fruit2 is now {}", fruit2);
  println!("Fruit is now {}", fruit); 
} </code></pre></pre>
<h2 id="temporary-references"><a class="header" href="#temporary-references">Temporary references</a></h2>
<p>As we have seen, in order for you to borrow a variable's value (i.e. obtain a reference), you do something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_apple = String::from("apple");
let your_apple = &amp;my_apple;
<span class="boring">}</span></code></pre></pre>
<p>where <code>my_apple</code> is the variable you are borrowing from abd <code>your_apple</code> is the borrowed value (i.e., reference to my_apple's value).
Thus, in order for us to borrow a variable's value, we do so via the name of the variable (in this case <code>my_apple</code>) whose value we want to borrow.</p>
<p>However, it is possible to create a borrow a value using a what I call a shorthand approach,
i.e., without using an intermediate variable as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let your_apple = &amp;String::from("apple");
<span class="boring">}</span></code></pre></pre>
<p>What actually happens for the above is that Rust will create a temporary variable for us behind the scenes and it is through
that temporary variable that the reference assigned to <code>your_apple</code> is created. That is, the snippet would essentially be expanded
to what we did in the first one:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let temp_variable_created_by_rust = String::from("apple");
let your_apple = &amp;temp_variable_created_by_rust;
<span class="boring">}</span></code></pre></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p><strong>References rules</strong></p>
<ul>
<li>At any given time, you can have either one mutable reference or many immutable references.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let mut fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp; mut fruit; //borrow occurs here i.e. fruit2 is a mutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  fruit2.push_str(" and pears"); //Do mutation
  
  //Both fruit and fruit2 refer to the same `String`
  //Crucially fruit2 which is a mutable reference to fruit, has exclusivity
  //i.e., we cannot have another mutable or non-mutable reference to fruit
  //while fruit2 is still in scope.
  
  //When the two lines below are uncommented, you get a compiler error
  //let fruit3 = &amp;fruit;  
  //println!("Fruit2 is now {}", fruit2);
  
  //You also get a compiler error if say you tried to use println! to
   //print fruit before fruit2. This is because the print/println macros
   //implicitly do a borrow of the variable you're trying to print

   //println!("Fruit is now {}", fruit); //println does an implicit borrow of `fruit` so the code will fail here
   //println!("Fruit2 is now {}", fruit2); //fruit2 which is a mutable borrow and thus has exclusivity to borrowing
   
   
   //correct thing to do here is:
   println!("Fruit2 is now {}", fruit2); //fruit2 goes out of scope since it's no longer used beyond this point
   
   //it is now safe to obtain another reference e.g. explicitly or through an implicit borrow as in the case of println
   let fruit3 = &amp;fruit;
   println!("Fruit is now {}", fruit); 
  
} </code></pre></pre>
<ul>
<li>References must always be valid i.e. a reference must always refer to a variable that is in scope.
<ul>
<li>A common example of Rust enforcing this rule
is the prevention of references from being returned from a function if that reference refers to a variable created in that function. This is because
that variable is part of that function's call stack and that call stack is destroyed when the function ends. Thus, if Rust allows the function to return a reference to such a variable from the function, that
reference would be a dangling reference  (i.e. it would be pointing to something that has been dropped) and this is a logic error. Thankfully, Rust compiler prevents you from doing this. If you create a variable that references heap allocated data (such as a <code>String</code>) in a function
and you want to return it from that function, what you'll want to do instead is to move it. That is,</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="moving_borrowing_slicing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="moving_borrowing_slicing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
