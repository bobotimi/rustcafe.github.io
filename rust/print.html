<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Olu&#x27;s Rust Cafe</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Olu&#x27;s Rust Cafe</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-me"><a class="header" href="#about-me">About me</a></h1>
<p>My name is Olu Shiyanbade ([linkedin](https://www.linkedin.com/in/olu-shiyanbade-8ba78335/] profile)). I'm a Software Engineer with 16 years development experience. I have experience with Java and common associated technologies/frameworks such as Spring and SpringBoot.
I also have experience with databases, Kubernetes, AWS and Azure.
I have recently become interested in Rust. The purpose of this site is to showcase what I learn on my Rust journey. Enjoy!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types-and-variables"><a class="header" href="#data-types-and-variables">Data types and Variables</a></h1>
<h2 id="data-types"><a class="header" href="#data-types">Data types</a></h2>
<p>The primitive (i.e. built in) data types in Rust can be sub divided into two namely:</p>
<ul>
<li>Scalar types</li>
<li>Compound types</li>
</ul>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar types</a></h3>
<p>Scalar types are types that can hold a single value.</p>
<ul>
<li>Numeric types: numeric types have a signed and an unsigned version. The numeric types in Rust are:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>u8</td><td>Unsigned 8 bit integer</td></tr>
<tr><td>i8</td><td>Signed 8 bit integer</td></tr>
<tr><td>u16</td><td>Unsigned 16 bit integer</td></tr>
<tr><td>i16</td><td>Signed 16 bit integer</td></tr>
<tr><td>u32</td><td>Unsigned 32 bit integer</td></tr>
<tr><td>i32</td><td>Signed 32 bit integer</td></tr>
<tr><td>u64</td><td>Unsigned 64 bit integer</td></tr>
<tr><td>i64</td><td>Signed 64 bit integer</td></tr>
<tr><td>f32</td><td>32 bit floating point</td></tr>
<tr><td>f64</td><td>64 bit floating point</td></tr>
</tbody></table>
</div>
<p>The non signed versions of the numeric types listed above can hold a value between -2 ^ N to (2 ^ N) - 1 while the unsigned versions can hold a value between 0 and (2 ^ N) - 1 where N is the number of bits. E.g. a i8 can hold value from -128 to 127 while a u8 can hold a value from 0 to 255.</p>
<ul>
<li>Non numeric types
<ul>
<li>bool: the boolean type i.e. true or false</li>
<li>char: can hold a single character e.g. 'A', 'B', 'C'</li>
</ul>
</li>
</ul>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound types</a></h3>
<p>Compound types are types that can hold two or more values. Rust has only two primitive compound types namely:</p>
<ul>
<li>Array</li>
<li>Tuple
See <a href="compound_types">Arrays and tuples</a> for more information</li>
</ul>
<h2 id="variable-declaration"><a class="header" href="#variable-declaration">Variable declaration</a></h2>
<p>You declare a variable in Rust using the <code>let</code> keyword. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num1 = 100;
let letter = 'A';
let amount = 7.5;
<span class="boring">}</span></code></pre></pre>
<p>Rust infers the type of the variable based on the value you assign to it at declaration. In the above,
variables num1, letter and amount are inferred to be i32, char and f64 respectively. If you like you can explicitly specify a type using a suffix as shown below in the case of numeric types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num1 = 100u8;
<span class="boring">}</span></code></pre></pre>
<p>or by specifiying the variable type explicitly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num2:u8 = 100;
let amount:f32 = 7.5;
<span class="boring">}</span></code></pre></pre>
<h2 id="variable-shadowing"><a class="header" href="#variable-shadowing">Variable shadowing</a></h2>
<p>In Rust, you can re-use a variable name in the same scope. When you do this, the old variable goes out of scope i.e. you can not use it anymore from that point.
You're essentially declaring a new variable and it's like the old variable never existed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = "Jack";

println!("The name is {}", name);

//shadow's previous variable
let name = "John";
println!("The name is {}", name);

<span class="boring">}</span></code></pre></pre>
<p>You can declare the variable as a completely different type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = "three";

println!("The number is {}", number);

//shadow's previous variable
let number = 3;
println!("The number is {}", number);
<span class="boring">}</span></code></pre></pre>
<h2 id="variables-and-immutability"><a class="header" href="#variables-and-immutability">Variables and immutability</a></h2>
<p>Variables are immutable by default in Rust. If you try to asign a new value to the above variable after the declaration you'll get a compiler error. That is,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num1 = 100;
num1 = 5; //compiler error
<span class="boring">}</span></code></pre></pre>
<p>To make a variable mutable, you must use the <code>mut</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num1 = 100;
println!("The number is {}", num1);
num1 = 5;
println!("The number is {}", num1);
<span class="boring">}</span></code></pre></pre>
<p>Note: that making a variable mutable is not the same as shadowing. When you declare a variable as mutable,
you're saying the value of that variable can be changed to another value which must be of the same data type as the initial
value. In addition, the variable doesn't go out of scope and you can continue to use the variable until the end of the current scope e.g. method, code block etc.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
   let mut name = "foo";
   println!("The name is {}", name);
   name = "bar"; //must be same data type
   println!("The name is {}", name);
   //name = 3; // compiler error
 } </code></pre></pre>
<p>On the other hand, with shadowing, you're declaring a completely new variable - it just so happens that you're using the
same name as the old variable. In this case, the old variable immediately goes out of scope and can no longer be used.
From then on, that name is associated with the new variable. This is why you can change the data type in the case of variable shadowing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = "hundred";

println!("The number is {}", number);

//shadow's previous variable
let number = 100;
println!("The number is {}", number);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ownership-and-borrowing"><a class="header" href="#understanding-ownership-and-borrowing">Understanding Ownership and Borrowing</a></h1>
<h2 id="stack-and-the-heap"><a class="header" href="#stack-and-the-heap">Stack and the heap</a></h2>
<ul>
<li>Data types that we know the size in advance are allocated on the stack.
Examples are the primitive types: ints, floats, chars, bools, tuples containing primitive types,</li>
<li>On the other hand, data types that we don't know the size in advance such as a String type or Vec<T> type are
allocated on the heap.
See <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack vs heap</a> for more info</li>
</ul>
<h2 id="copying-vs-moving"><a class="header" href="#copying-vs-moving">Copying vs Moving</a></h2>
<ul>
<li>Types that implement the Copy trait are copied when you assign them to a variable (or pass it as an argument to a function).
For example:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let number1 = 10;
   println!("number1 is {}", number1);
   
   let mut number2 = number1;
   println!("number2 is {}", number2);
   number2 = 97;
   println!("number2 is now {}", number2);
   
   println!("number1 is still {}", number1);
 }</code></pre></pre>
<ul>
<li>Types that do not implement Copy but instead implement the Drop trait are moved when you re-assign a variable of such type
(or pass it as an argument to a function). This means the new variable you have assigned it to is now the new <strong>owner</strong> of that data.
Examples of Rust built-in types that implement the Drop trait are String, Vec, File etc</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
   let fruit = String::from("apple");
   println!("fruit is {}", fruit);
   
   //fruit is moved into fruit2
   let fruit2 = fruit;
   println!("fruit2 is {}", fruit2);
   
   //cannot use fruit here
   //println!("{} is no longer in scope, it has been dropped", fruit);
}</code></pre></pre>
<p>If you uncomment, the last line in the above snippet and run the snippet, you'll see error messages about moving.</p>
<p>Same thing happens for method calls:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
   let fruit = String::from("apple");
   println!("fruit is {}", fruit);
   
   let mut basket:Vec&lt;String&gt; = vec![];
   
   println!("basket is {:#?}", basket);
   
   //fruit is moved into the function
   put_in_basket(fruit, &amp;mut basket);
   
   println!("basket is {:#?}", basket);
   
   //cannot use fruit here
   //println!("{} is no longer in scope, it has been dropped", fruit);
}

fn put_in_basket(theFruit: String, basket: &amp;mut Vec&lt;String&gt;) {
   basket.push(theFruit);
}</code></pre></pre>
<p>If you uncomment, the last line in the above snippet and run the snippet, you'll see error messages about moving.</p>
<h1 id="borrowing-and-ownership"><a class="header" href="#borrowing-and-ownership">Borrowing and Ownership</a></h1>
<p>There are three rules related to ownership in Rust namely:</p>
<ul>
<li>Every value in Rust has an owner</li>
<li>There can be only one owner at a time</li>
<li>When the owner goes out of scope, the data/value is dropped
(Source: <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-rules">ownership rules</a> )</li>
</ul>
<h2 id="who-owns-what"><a class="header" href="#who-owns-what">Who owns what?</a></h2>
<p>In Rust, ownership really only makes sense when you think about types which are allocated on the heap such as <code>String</code>.
These types also implement the <code>Drop</code> trait which allows such types to be cleaned up when they go out of scope.
On the other hand, primitive types such as integers (signed and unsigned), chars, bools, tuples
etc (as seen <a href="ownership.html#copying-vs-moving">above</a> ), are simply copied when you reassign variables of these types to a another variable or pass as method argument.</p>
<h3 id="ownership-examples"><a class="header" href="#ownership-examples">Ownership examples</a></h3>
<p>Whenever you create an object on the heap and assign that object to a variable, the owner of that object is the variable you assigned it to.
To understand ownership, we need to use a type like <code>String</code> which is allocated on the heap.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let name = String::from("Olu Shiyanbade");
}</code></pre></pre>
<p>In the above, we build a new <code>String</code> which is allocated on the heap. The location of that <code>String</code> is
assigned to the variable <code>name</code> which is in turn allocated on the stack. In this statement, variable <code>name</code> is said to be
the <strong>owner</strong> of the <code>String</code>.</p>
<h4 id="changing-ownership"><a class="header" href="#changing-ownership">Changing ownership</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let name = String::from("Olu Shiyanbade");
  
  println!("In main, name is {}", name);
  
  let another_name = name;
  println!("In main, another_name is {}", another_name);
  
  //Can no longer use name because the owner is now variable `another_name`
  //println!("In main, name is {}", name);
  
  print_name(another_name);
 
  //Can no longer use another_name because the ownership was moved into the 
  //function's paramater when it was passed as an argument above.
  // Thus the owner is now the function parameter `name`
  //println!("name is {}", another_name);
}

fn print_name(name: String) {
  println!("In print_name, name is: {}", name);
}</code></pre></pre>
<p>In the above,</p>
<ul>
<li>the String <code>Olu Shiyanbade</code> is initially owned by the <code>name</code> variable.</li>
<li>the snippet <code>let another_name = name;</code> assigns <code>name</code> to <code>another_name</code>. At this point, we say <code>name</code> is <strong>moved</strong> into <code>another_name</code> and <code>another_name</code> becomes the <strong>owner</strong>
of the String <code>Olu Shiyanbade</code> while variable <code>name</code> goes out of scope (i.e. it is dropped).</li>
<li>similarly, when we do <code>print_name(another_name</code>, <code>another_name</code> is moved into the
<code>print_name</code> function and that function's <code>name</code> parameter becomes the new owner. At this point <code>another_name</code> goes
out of scope and can no longer be used beyond that point.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowingreferences"><a class="header" href="#borrowingreferences">Borrowing/References</a></h1>
<p>Borrowing in Rust means obtaining a reference to some variable.
From now on, we'll use phrases "obtaining a reference" and "borrowing" interchangeably.
When you obtain a reference to a variable <code>foo</code> and assign it to another variable <code>bar</code>,
the variable <code>bar</code> is the borrower and the variable <code>foo</code> is the owner/lender. Thus, <code>bar</code> refers
to <code>foo</code> or we can say <code>bar</code> borrows <code>foo</code>'s value.
Variable <code>bar</code> can freely read the data owned by <code>foo</code> but it cannot modify the data unless otherwise specified via the <code>mut</code> keyword.
(more on this below)</p>
<p>Usually in Rust, when you want to assign a heap allocated variable to another variable
or pass it to a function, what you want is to <em>borrow</em> the data that variable refers to (or succinctly borrow the variable) rather than taking ownership of it as we
saw in the previous section. In order to <em>borrow</em> a variable, you obtain a reference to that variable.</p>
<p>Let's use the <code>String</code> type as an example:</p>
<pre><pre class="playground"><code class="language-rust editable">
fn main() {
  let fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp;fruit; //borrow occurs here i.e. fruit2 is a reference to fruit

  println!("Fruit2 is {}", fruit2);
  
  //Can still use fruit variable here
  println!("Fruit is {}", fruit);
} </code></pre></pre>
<p>Similarly, for method calls, you can pass a reference as argument (i.e. borrowed the variable)
to the function call like so:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let name = String::from("Olu");

  println!("Name is {}", name);

  say_hello(&amp;name); //borrow occurs here
  
  //Can still use name variable here
  println!("Name is {}", name);
} 

fn say_hello(name: &amp;String) { //name is a reference to a String passed into the function
   println!("Hello {}", name)
}</code></pre></pre>
<h2 id="what-actually-happens-when-you-assign"><a class="header" href="#what-actually-happens-when-you-assign">What actually happens when you assign</a></h2>
<h2 id="a-reference-ie-a-borrowed-variable-is-immutable-by-default"><a class="header" href="#a-reference-ie-a-borrowed-variable-is-immutable-by-default">A reference (i.e. a borrowed variable) is immutable by default</a></h2>
<p>By default, when you borrow a variable, the reference is immutable. That is, by default, you cannot<br />
use the reference to change the variable. Example, the below snippet fails:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp;fruit; //borrow occurs here i.e. fruit2 is an immutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  let another_fruit = String::from("pear");
  
  fruit2 = &amp;another_fruit; //compiler error here
  
  println!("Fruit2 is now {}", fruit2);
} </code></pre></pre>
<p>You'll see from the error message shown that <code>fruit2</code> is immutable by default, just like any other
rust variable (i.e. when you do a <code>let foo = ...</code>, the variable, reference or not, is always immutable by default).
Adding the <code>mut</code> keyword to <code>fruit2</code> declaration sorts it:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let mut fruit2 = &amp;fruit; //borrow occurs here i.e. fruit2 is a mutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  let another_fruit = String::from("pear");
  
  fruit2 = &amp;another_fruit; //Now you can assign a new reference to fruit2
  
  println!("Fruit is still {}", fruit); // still refers to the the "apple" String
  println!("Fruit2 is now {}", fruit2); //now refers to the "pear" String
} </code></pre></pre>
<p>In the above, example, we initially assigned a reference to a <code>String</code> containing "apple"
to <code>fruit2</code> and then we assigned another reference to a different <code>String</code> containing "pear"
to <code>fruit</code>. Thus we made <code>fruit2</code> refer to two different Strings (one at a time) over the course of the program.
What if we wanted to use <code>fruit2</code> to modify the original String i.e. the <code>String::from("apple")</code>?</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let mut fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp; mut fruit; //borrow occurs here i.e. fruit2 is a mutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  fruit2.push_str(" and pears");
  
  //Both fruit and fruit2 refer to the same `String`
  println!("Fruit2 is now {}", fruit2);
  println!("Fruit is now {}", fruit); 
} </code></pre></pre>
<h2 id="temporary-references"><a class="header" href="#temporary-references">Temporary references</a></h2>
<p>As we have seen, in order for you to borrow a variable's value (i.e. obtain a reference), you do something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_apple = String::from("apple");
let your_apple = &amp;my_apple;
<span class="boring">}</span></code></pre></pre>
<p>where <code>my_apple</code> is the variable you are borrowing from abd <code>your_apple</code> is the borrowed value (i.e., reference to my_apple's value).
Thus, in order for us to borrow a variable's value, we do so via the name of the variable (in this case <code>my_apple</code>) whose value we want to borrow.</p>
<p>However, it is possible to create a borrow a value using a what I call a shorthand approach,
i.e., without using an intermediate variable as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let your_apple = &amp;String::from("apple");
<span class="boring">}</span></code></pre></pre>
<p>What actually happens for the above is that Rust will create a temporary variable for us behind the scenes and it is through
that temporary variable that the reference assigned to <code>your_apple</code> is created. That is, the snippet would essentially be expanded
to what we did in the first one:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let temp_variable_created_by_rust = String::from("apple");
let your_apple = &amp;temp_variable_created_by_rust;
<span class="boring">}</span></code></pre></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p><strong>References rules</strong></p>
<ul>
<li>At any given time, you can have either one mutable reference or many immutable references.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
  let mut fruit = String::from("apple");

  println!("Fruit is {}", fruit);

  let fruit2 = &amp; mut fruit; //borrow occurs here i.e. fruit2 is a mutable reference to fruit
  
  println!("Fruit2 is {}", fruit2);
  
  fruit2.push_str(" and pears"); //Do mutation
  
  //Both fruit and fruit2 refer to the same `String`
  //Crucially fruit2 which is a mutable reference to fruit, has exclusivity
  //i.e., we cannot have another mutable or non-mutable reference to fruit
  //while fruit2 is still in scope.
  
  //When the two lines below are uncommented, you get a compiler error
  //let fruit3 = &amp;fruit;  
  //println!("Fruit2 is now {}", fruit2);
  
  //You also get a compiler error if say you tried to use println! to
   //print fruit before fruit2. This is because the print/println macros
   //implicitly do a borrow of the variable you're trying to print

   //println!("Fruit is now {}", fruit); //println does an implicit borrow of `fruit` so the code will fail here
   //println!("Fruit2 is now {}", fruit2); //fruit2 which is a mutable borrow and thus has exclusivity to borrowing
   
   
   //correct thing to do here is:
   println!("Fruit2 is now {}", fruit2); //fruit2 goes out of scope since it's no longer used beyond this point
   
   //it is now safe to obtain another reference e.g. explicitly or through an implicit borrow as in the case of println
   let fruit3 = &amp;fruit;
   println!("Fruit is now {}", fruit); 
  
} </code></pre></pre>
<ul>
<li>References must always be valid i.e. a reference must always refer to a variable that is in scope.
<ul>
<li>A common example of Rust enforcing this rule
is the prevention of references from being returned from a function if that reference refers to a variable created in that function. This is because
that variable is part of that function's call stack and that call stack is destroyed when the function ends. Thus, if Rust allows the function to return a reference to such a variable from the function, that
reference would be a dangling reference  (i.e. it would be pointing to something that has been dropped) and this is a logic error. Thankfully, Rust compiler prevents you from doing this. If you create a variable that references heap allocated data (such as a <code>String</code>) in a function
and you want to return it from that function, what you'll want to do instead is to move it. That is,</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
